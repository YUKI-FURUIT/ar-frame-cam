<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>フルスクリーン・フレーム付きカメラ</title>
<style>
  :root { --pad: max(12px, env(safe-area-inset-bottom)); }
  html,body{margin:0;height:100%;background:#000;color:#fff;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Noto Sans JP,sans-serif}
  .stage{position:fixed; inset:0; overflow:hidden; background:#000;}
  video#cam{position:absolute; inset:0; width:100%; height:100%; object-fit:cover;}
  img#frame{position:absolute; left:50%; top:50%; transform:translate(-50%,-50%) scale(1) rotate(0deg); transform-origin:center center; pointer-events:none; user-select:none; max-width:100%; max-height:100%;}
  .touch-layer{position:absolute; inset:0; touch-action:none;}
  .ui{position:fixed; left:0; right:0; bottom:0; display:flex; gap:8px; justify-content:center; padding: var(--pad); background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,.5) 40%, rgba(0,0,0,.7) 100%); }
  button,label.btn{appearance:none; border:0; border-radius:999px; padding:10px 14px; background:#2d2f39; color:#fff; font-size:14px}
  input[type=file]{display:none}
  .topbar{position:fixed; left:0; right:0; top:0; padding:10px; display:flex; justify-content:space-between; gap:8px; background: linear-gradient(180deg, rgba(0,0,0,.65), rgba(0,0,0,0));}
  .ghost{opacity:.6}
  .range{appearance:none;width:160px}
</style>
</head>
<body>
  <div class="stage" id="stage">
    <video id="cam" playsinline autoplay muted></video>
    <img id="frame" alt="frame">
    <div class="touch-layer" id="touch"></div>
  </div>

  <div class="topbar">
    <span class="ghost" id="hint">ピンチで拡大・回転／ドラッグで移動</span>
    <div>
      透明度 <input id="alpha" class="range" type="range" min="0" max="100" value="100">
    </div>
  </div>

  <div class="ui">
    <button id="start">カメラ開始</button>
    <button id="flip">カメラ切替</button>
    <label class="btn" for="file">フレーム選択</label>
    <input id="file" type="file" accept="image/png,image/*">
    <button id="reset">リセット</button>
  </div>

<script>
  const video = document.getElementById('cam');
  const frame = document.getElementById('frame');
  const touch = document.getElementById('touch');
  const alpha = document.getElementById('alpha');
  let stream; let usingBack = true;

  // フレーム状態
  const S = { x: 0, y: 0, scale: 1, rot: 0 };
  function apply() {
    frame.style.opacity = (alpha.value/100).toString();
    frame.style.transform = `translate(calc(-50% + ${S.x}px), calc(-50% + ${S.y}px)) scale(${S.scale}) rotate(${S.rot}deg)`;
  }

  async function startCamera() {
    try {
      if (stream) stream.getTracks().forEach(t=>t.stop());
      stream = await navigator.mediaDevices.getUserMedia({
        audio:false,
        video:{ facingMode: usingBack ? { exact:'environment' } : 'user', width:{ ideal:1920 }, height:{ ideal:1080 } }
      });
      video.srcObject = stream;
      video.style.transform = usingBack ? 'scaleX(1)' : 'scaleX(-1)'; // 自撮りはミラー
    } catch(e) {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
        video.srcObject = stream;
      } catch(err) {
        alert('カメラ開始に失敗。HTTPSと権限を確認してください\n' + (err?.message||''));
      }
    }
  }

  document.getElementById('start').onclick = startCamera;
  document.getElementById('flip').onclick = async ()=>{ usingBack = !usingBack; await startCamera(); };
  document.getElementById('reset').onclick = ()=>{ S.x=0; S.y=0; S.scale=1; S.rot=0; apply(); };
  alpha.oninput = apply;

  // PNG読み込み（端末内のみ、一時利用）
  document.getElementById('file').onchange = (e)=>{
    const f = e.target.files?.[0];
    if(!f) return;
    const url = URL.createObjectURL(f);
    frame.onload = ()=> URL.revokeObjectURL(url);
    frame.src = url;
    S.x=0; S.y=0; S.scale=1; S.rot=0; apply();
  };

  // タッチ操作（ドラッグ、ピンチ、回転）
  let touches = new Map();
  let start = null; // {x,y,d,a, x0,y0, scale0, rot0}
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function angle(a,b){ return Math.atan2(b.y-a.y, b.x-a.x); }
  const getTouches = () => Array.from(touches.values());

  touch.addEventListener('touchstart', (e)=>{
    e.preventDefault();
    for (const t of e.changedTouches) touches.set(t.identifier, { x:t.clientX, y:t.clientY });
    const ts = getTouches();
    if (ts.length===1) {
      start = { x:ts[0].x, y:ts[0].y, x0:S.x, y0:S.y, scale0:S.scale, rot0:S.rot };
    } else if (ts.length>=2) {
      const d = dist(ts[0], ts[1]), a = angle(ts[0], ts[1]);
      start = { x:(ts[0].x+ts[1].x)/2, y:(ts[0].y+ts[1].y)/2, d, a, x0:S.x, y0:S.y, scale0:S.scale, rot0:S.rot };
    }
  }, {passive:false});

  touch.addEventListener('touchmove', (e)=>{
    e.preventDefault();
    for (const t of e.changedTouches) if (touches.has(t.identifier)) touches.set(t.identifier, { x:t.clientX, y:t.clientY });
    if (!start) return;
    const ts = getTouches();
    if (ts.length===1) {
      S.x = start.x0 + (ts[0].x - start.x);
      S.y = start.y0 + (ts[0].y - start.y);
    } else if (ts.length>=2) {
      const d = dist(ts[0], ts[1]), a = angle(ts[0], ts[1]);
      S.scale = Math.max(0.1, start.scale0 * (d / start.d));
      S.rot = start.rot0 + ((a - start.a) * 180/Math.PI);
      const cx=(ts[0].x+ts[1].x)/2, cy=(ts[0].y+ts[1].y)/2;
      S.x = start.x0 + (cx - start.x);
      S.y = start.y0 + (cy - start.y);
    }
    apply();
  }, {passive:false});

  function end(e){
    for (const t of e.changedTouches) touches.delete(t.identifier);
    if (getTouches().length===0) start = null;
  }
  touch.addEventListener('touchend', end);
  touch.addEventListener('touchcancel', end);

  // マウス操作（PC確認用）
  let dragging=false, lx=0, ly=0;
  touch.addEventListener('mousedown', (e)=>{ dragging=true; lx=e.clientX; ly=e.clientY; });
  window.addEventListener('mousemove', (e)=>{
    if(!dragging) return;
    S.x += e.clientX - lx; S.y += e.clientY - ly; lx=e.clientX; ly=e.clientY; apply();
  });
  window.addEventListener('mouseup', ()=> dragging=false);
  window.addEventListener('wheel', (e)=>{
    const f = e.deltaY<0 ? 1.05 : 0.95;
    S.scale = Math.max(0.1, S.scale * f); apply();
  }, {passive:true});

  // ヒントを数秒で薄く
  setTimeout(()=> document.getElementById('hint').style.opacity = .0, 4000);
</script>
</body>
</html>
